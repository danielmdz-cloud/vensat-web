"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Actions = void 0;
const eventsource_1 = __importDefault(require("eventsource"));
const axios_1 = __importDefault(require("axios"));
function GenerateContentFromPreset({ label, mainListField, customPrompt, allowOverrideCustomPrompt, modelsConfig }) {
    return {
        type: 'model',
        name: '_create_from_preset_ai',
        label: label ?? 'Generate content with AI',
        models: modelsConfig ? modelsConfig.map((model) => model.name) : undefined,
        inputFields: [
            {
                type: 'slug',
                name: 'slug',
                label: 'Slug'
            },
            ...(allowOverrideCustomPrompt
                ? [
                    {
                        type: 'text',
                        name: 'customPrompt',
                        label: 'Custom Prompt',
                        default: customPrompt
                    }
                ]
                : [])
        ],
        run: async (options) => {
            const logger = options.getLogger();
            logger.info(`generate content from preset`);
            const schemas = options.getSchemas();
            const modelsByName = {};
            for (const schema of schemas) {
                for (const model of schema.models) {
                    modelsByName[model.name] = model;
                }
            }
            const sparkClient = new SparkClient({
                apiKey: process.env.SPARK_API_KEY,
                url: process.env.SPARK_URL,
                logger
            });
            const modelConf = (modelsConfig ?? []).find((model) => model.name === options.actionModel.name);
            if (modelConf) {
                mainListField = modelConf.mainListField ?? mainListField;
                customPrompt = modelConf.customPrompt ?? customPrompt;
            }
            const progressCallback = createProgressCallback(options.progress);
            progressCallback({
                percent: 0,
                categoryMessage: 'Initializing',
                progressMessage: 'Initializing'
            });
            const googleDoc = await fetchGoogleDoc(options, progressCallback);
            if (googleDoc) {
                logger.debug('got google doc');
            }
            const result = await sparkClient.performContentGen({
                contentUrl: options.inputData?._spark_ai_content,
                contentMarkdown: googleDoc,
                knowledge: getKnowledgeForInputData(options.inputData),
                preset: options.inputData?.presetData,
                customPrompt: options.inputData?.customPrompt ?? customPrompt,
                modelName: options.actionModel.name,
                sectionsField: mainListField,
                engineName: 'openai',
                modelsByName,
                progressCallback
            });
            if (options.inputData?.slug) {
                result.slug = options.inputData?.slug;
            }
            logger.info('create document');
            progressCallback({
                percent: 95,
                categoryMessage: 'Saving content',
                progressMessage: 'Saving content'
            });
            const { documentId } = await options.contentSourceActions.createDocumentFromObject({
                modelName: options.actionModel.name,
                object: result
            });
            logger.info(`created document with ID: '${documentId}'`);
            return {
                success: 'Successfully generated document',
                result: { documentId }
            };
        }
    };
}
class SparkClient {
    constructor({ apiKey, url, logger }) {
        this.apiKey = apiKey;
        this.url = url;
        this.logger = logger;
    }
    async performContentGen({ contentUrl, contentMarkdown, knowledge, preset, modelName, sectionsField, customPrompt, engineName, modelsByName, progressCallback }) {
        const presetData = JSON.stringify(preset);
        const modelsByNameData = JSON.stringify(modelsByName);
        this.logger.debug('initialize content-gen workload');
        if (contentMarkdown) {
            contentUrl = undefined;
        }
        const initializedWorkload = await (0, axios_1.default)({
            url: `${this.url}/api/v1/workload/content-gen`,
            method: 'post',
            headers: {
                'Content-Type': 'application/json',
                'x-spark-api-key': this.apiKey
            },
            data: {
                inputs: {
                    url: contentUrl,
                    model: modelName,
                    engine: engineName ?? 'openai',
                    sectionsField: sectionsField,
                    customPrompt: customPrompt
                },
                uploads: {
                    createData: {
                        preset: hashCode(presetData),
                        modelsByName: hashCode(modelsByNameData)
                    },
                    ...(contentMarkdown
                        ? {
                            sourceData: {
                                sourceContent: hashCode(contentMarkdown)
                            }
                        }
                        : {})
                },
                knowledge
            }
        });
        // all of our signed urls are set on this workload result object.
        const initializedWorkloadResult = initializedWorkload.data;
        this.logger.debug('initialized workload');
        if (!initializedWorkloadResult.startWorkload) {
            throw new Error('workload must specify startWorkload URL');
        }
        // upload the resources we specified that we would upload on the original init call
        this.logger.debug('uploading workload createData');
        progressCallback({
            percent: 5,
            categoryMessage: 'Initializing',
            progressMessage: 'Uploading content'
        });
        await Promise.all([
            (0, axios_1.default)({
                url: initializedWorkloadResult.requiredUploads.createData.preset,
                method: 'post',
                headers: { 'Content-Type': 'application/json' },
                data: preset
            }),
            (0, axios_1.default)({
                url: initializedWorkloadResult.requiredUploads.createData.modelsByName,
                method: 'post',
                headers: { 'Content-Type': 'application/json' },
                data: modelsByName
            }),
            ...(contentMarkdown
                ? [
                    (0, axios_1.default)({
                        url: initializedWorkloadResult.requiredUploads.sourceData.sourceContent,
                        method: 'post',
                        headers: { 'Content-Type': 'application/json' },
                        data: contentMarkdown
                    })
                ]
                : [])
        ]);
        // now that all files are uploaded, kick off the workload
        await (0, axios_1.default)({
            url: initializedWorkloadResult.startWorkload,
            method: 'post'
        });
        this.logger.debug('started workload');
        // wait until the workload is done
        await this.waitUntilDone({
            sseUrl: initializedWorkloadResult.progress.sse,
            progressCallback: (sparkEvent) => {
                progressCallback(null, sparkEvent);
            }
        });
        // fetch the result
        this.logger.debug('workload finished, fetching workload result');
        const workloadResult = await (0, axios_1.default)({
            url: initializedWorkloadResult.workloadResult,
            method: 'get'
        });
        this.logger.debug('got workload result', {
            status: workloadResult.status,
            statusText: workloadResult.statusText
        });
        return workloadResult.data;
    }
    waitUntilDone({ sseUrl, progressCallback, retryCount = 0 }) {
        this.logger.debug('subscribe to server-side-events', { retryCount });
        const sse = new eventsource_1.default(sseUrl);
        return new Promise((resolve, reject) => {
            sse.onerror = (event) => {
                sse.close();
                this.logger.error('server-side-event error', { event });
                if (retryCount < 3) {
                    setTimeout(() => {
                        resolve(this.waitUntilDone({
                            sseUrl,
                            progressCallback,
                            retryCount: retryCount + 1
                        }));
                    }, 1000);
                }
                else {
                    this.logger.error('got 3 server-side-event errors, aborting');
                    reject(new Error('SSE failed'));
                }
            };
            sse.addEventListener('message', (event) => {
                this.logger.debug('eventsource event:', { event });
                try {
                    const sparkEvent = JSON.parse(event.data);
                    if (!sparkEvent.latest) {
                        return;
                    }
                    progressCallback?.(sparkEvent);
                    const percentage = sparkEvent.latest.percentage;
                    if (typeof percentage === 'number' && percentage === 100) {
                        sse.close();
                        resolve();
                    }
                }
                catch (error) {
                    sse.close();
                    reject(new Error('Could not parse Spark event'));
                }
            });
        });
    }
}
function createProgressCallback(progressCallback) {
    const localProgressBefore = [];
    const localProgressAfter = [];
    let remoteProgress = [];
    let gotRemoteEvents = false;
    const adjustPercentage = (percentage) => {
        return 10 + Math.floor((percentage ?? 0) * 0.8);
    };
    return (localEvent, remoteSparkEvent) => {
        let sparkEvent;
        if (remoteSparkEvent) {
            gotRemoteEvents = true;
            remoteProgress =
                remoteSparkEvent.allProgress?.map((step) => {
                    return {
                        ...step,
                        percentage: adjustPercentage(step.percentage)
                    };
                }) ?? remoteProgress;
            if (remoteSparkEvent.latest) {
                sparkEvent = {
                    ...remoteSparkEvent,
                    latest: {
                        ...remoteSparkEvent.latest,
                        percentage: adjustPercentage(remoteSparkEvent.latest.percentage)
                    },
                    allProgress: localProgressBefore.concat(remoteProgress ?? [])
                };
            }
        }
        else if (localEvent) {
            const latest = createSparkEventProgressMessage(localEvent);
            if (!gotRemoteEvents) {
                localProgressBefore.push(latest);
                sparkEvent = {
                    latest,
                    allProgress: localProgressBefore
                };
            }
            else {
                localProgressAfter.push(latest);
                sparkEvent = {
                    latest,
                    allProgress: localProgressBefore.concat(remoteProgress, localProgressAfter)
                };
            }
        }
        if (sparkEvent?.latest) {
            progressCallback?.({
                percent: sparkEvent.latest?.percentage,
                message: JSON.stringify(sparkEvent)
            });
        }
    };
}
function createSparkEventProgressMessage(options) {
    return {
        percentage: options.percent,
        categoryMessage: options.categoryMessage,
        progressMessage: options.progressMessage,
        systemFailure: options.systemFailure,
        errorMessage: options.errorMessage
    };
}
function hashCode(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
        const code = str.charCodeAt(i);
        hash = (hash << 5) - hash + code;
        hash = hash & hash; // Convert to 32bit integer
    }
    return hash;
}
function getKnowledgeForInputData(inputData) {
    if (!inputData) {
        return undefined;
    }
    const selected = [];
    if (inputData._spark_ai_voiceTone) {
        selected.push({
            type: 'voice-and-tone',
            id: inputData._spark_ai_voiceTone
        });
    }
    if (inputData._spark_ai_targetAudience) {
        selected.push({
            type: 'target-audience',
            id: inputData._spark_ai_targetAudience
        });
    }
    if (selected.length === 0) {
        return undefined;
    }
    return {
        scopes: {
            shared: 'netlify-known'
        },
        selected
    };
}
async function fetchGoogleDoc(options, progressCallback) {
    const googleDocUrl = options.inputData?._spark_ai_googleDocUrl ?? options.inputData?._spark_ai_content;
    const match = googleDocUrl?.match(/docs\.google\.com\/document\/d\/([^/]+)\//);
    if (!match) {
        return;
    }
    const googleDocId = match[1];
    if (!googleDocId) {
        return;
    }
    let googleConnection;
    if (options.currentUser && 'connections' in options.currentUser && Array.isArray(options.currentUser.connections)) {
        googleConnection = options.currentUser.connections.find((connection) => connection.type === 'google');
    }
    if (!googleConnection || !('accessToken' in googleConnection)) {
        throw new Error('Please connect your google account');
    }
    progressCallback({
        percent: 2,
        categoryMessage: 'Initializing',
        progressMessage: `Fetching from ${googleDocUrl}`
    });
    // const url = `https://docs.google.com/feeds/download/documents/export/Export?id=${documentId}&exportFormat=markdown`;
    const url = `https://www.googleapis.com/drive/v3/files/${googleDocId}/export?mimeType=text/markdown`;
    const googleDocResult = await (0, axios_1.default)({
        url: url,
        method: 'get',
        headers: {
            Authorization: `Bearer ${googleConnection.accessToken}`
        }
    });
    return googleDocResult.data;
}
exports.Actions = {
    GenerateContentFromPreset
};
//# sourceMappingURL=ai-actions.js.map