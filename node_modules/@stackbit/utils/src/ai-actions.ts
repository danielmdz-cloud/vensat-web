import EventSource from 'eventsource';
import axios from 'axios';
import {
    CustomActionModel,
    CustomActionRunCommonOptions,
    CustomActionModelRunOptions,
    CustomActionInputField,
    CustomActionProgressFunction,
    ModelMap,
    Logger
} from '@stackbit/types';

export type GenerateContentFromPresetOptions = {
    /**
     * The label for the AI action.
     * @default Generate content with AI
     */
    label?: string;
    /**
     * The name of the field that contains the page's section.
     * For example, 'sections', 'blocks', 'components'.
     * Use `modelsConfig.mailListField` when setting root config actions.
     */
    mainListField?: string;
    /**
     * Custom AI prompt.
     * Use `modelsConfig.customPrompt` when setting root config actions.
     */
    customPrompt?: string;
    /**
     * Allow content editor to change the custom prompt.
     */
    allowOverrideCustomPrompt?: boolean;
    /**
     * Use `modelsConfig` when setting root config actions, and specify
     * `mainListField` and `customPrompt` per model `name`.
     */
    modelsConfig?: {
        name: string;
        mainListField?: string;
        customPrompt?: string;
    }[];
};

function GenerateContentFromPreset({
    label,
    mainListField,
    customPrompt,
    allowOverrideCustomPrompt,
    modelsConfig
}: GenerateContentFromPresetOptions): CustomActionModel {
    return {
        type: 'model',
        name: '_create_from_preset_ai',
        label: label ?? 'Generate content with AI',
        models: modelsConfig ? modelsConfig.map((model) => model.name) : undefined,
        inputFields: [
            {
                type: 'slug',
                name: 'slug',
                label: 'Slug'
            },
            ...(allowOverrideCustomPrompt
                ? [
                      {
                          type: 'text',
                          name: 'customPrompt',
                          label: 'Custom Prompt',
                          default: customPrompt
                      } satisfies CustomActionInputField
                  ]
                : [])
        ],
        run: async (options: CustomActionRunCommonOptions & CustomActionModelRunOptions) => {
            const logger = options.getLogger();
            logger.info(`generate content from preset`);

            const schemas = options.getSchemas();
            const modelsByName: ModelMap = {};
            for (const schema of schemas) {
                for (const model of schema.models) {
                    modelsByName[model.name] = model;
                }
            }

            const sparkClient = new SparkClient({
                apiKey: process.env.SPARK_API_KEY!,
                url: process.env.SPARK_URL!,
                logger
            });

            const modelConf = (modelsConfig ?? []).find((model) => model.name === options.actionModel.name);
            if (modelConf) {
                mainListField = modelConf.mainListField ?? mainListField;
                customPrompt = modelConf.customPrompt ?? customPrompt;
            }

            const progressCallback = createProgressCallback(options.progress);

            progressCallback({
                percent: 0,
                categoryMessage: 'Initializing',
                progressMessage: 'Initializing'
            });

            const googleDoc = await fetchGoogleDoc(options, progressCallback);
            if (googleDoc) {
                logger.debug('got google doc');
            }

            const result = await sparkClient.performContentGen({
                contentUrl: options.inputData?._spark_ai_content,
                contentMarkdown: googleDoc,
                knowledge: getKnowledgeForInputData(options.inputData),
                preset: options.inputData?.presetData,
                customPrompt: options.inputData?.customPrompt ?? customPrompt,
                modelName: options.actionModel.name,
                sectionsField: mainListField,
                engineName: 'openai',
                modelsByName,
                progressCallback
            });

            if (options.inputData?.slug) {
                result.slug = options.inputData?.slug;
            }

            logger.info('create document');
            progressCallback({
                percent: 95,
                categoryMessage: 'Saving content',
                progressMessage: 'Saving content'
            });
            const { documentId } = await options.contentSourceActions.createDocumentFromObject({
                modelName: options.actionModel.name,
                object: result
            });
            logger.info(`created document with ID: '${documentId}'`);
            return {
                success: 'Successfully generated document',
                result: { documentId }
            };
        }
    };
}

class SparkClient {
    private readonly apiKey: string;
    private readonly url: string;
    private readonly logger: Logger;

    constructor({ apiKey, url, logger }: { apiKey: string; url: string; logger: any }) {
        this.apiKey = apiKey;
        this.url = url;
        this.logger = logger;
    }

    async performContentGen({
        contentUrl,
        contentMarkdown,
        knowledge,
        preset,
        modelName,
        sectionsField,
        customPrompt,
        engineName,
        modelsByName,
        progressCallback
    }: {
        contentUrl?: string;
        contentMarkdown?: string;
        knowledge?: SparkKnowledge;
        preset: any;
        modelName: string;
        sectionsField?: string;
        customPrompt?: string;
        engineName?: string;
        modelsByName: Record<string, any>;
        progressCallback: ProgressCallback;
    }) {
        const presetData = JSON.stringify(preset);
        const modelsByNameData = JSON.stringify(modelsByName);

        this.logger.debug('initialize content-gen workload');

        if (contentMarkdown) {
            contentUrl = undefined;
        }

        const initializedWorkload = await axios({
            url: `${this.url}/api/v1/workload/content-gen`,
            method: 'post',
            headers: {
                'Content-Type': 'application/json',
                'x-spark-api-key': this.apiKey
            },
            data: {
                inputs: {
                    url: contentUrl,
                    model: modelName,
                    engine: engineName ?? 'openai',
                    sectionsField: sectionsField,
                    customPrompt: customPrompt
                },
                uploads: {
                    createData: {
                        preset: hashCode(presetData),
                        modelsByName: hashCode(modelsByNameData)
                    },
                    ...(contentMarkdown
                        ? {
                              sourceData: {
                                  sourceContent: hashCode(contentMarkdown)
                              }
                          }
                        : {})
                },
                knowledge
            }
        });

        // all of our signed urls are set on this workload result object.
        const initializedWorkloadResult = initializedWorkload.data;
        this.logger.debug('initialized workload');

        if (!initializedWorkloadResult.startWorkload) {
            throw new Error('workload must specify startWorkload URL');
        }

        // upload the resources we specified that we would upload on the original init call
        this.logger.debug('uploading workload createData');
        progressCallback({
            percent: 5,
            categoryMessage: 'Initializing',
            progressMessage: 'Uploading content'
        });
        await Promise.all([
            axios({
                url: initializedWorkloadResult.requiredUploads.createData.preset,
                method: 'post',
                headers: { 'Content-Type': 'application/json' },
                data: preset
            }),
            axios({
                url: initializedWorkloadResult.requiredUploads.createData.modelsByName,
                method: 'post',
                headers: { 'Content-Type': 'application/json' },
                data: modelsByName
            }),
            ...(contentMarkdown
                ? [
                      axios({
                          url: initializedWorkloadResult.requiredUploads.sourceData.sourceContent,
                          method: 'post',
                          headers: { 'Content-Type': 'application/json' },
                          data: contentMarkdown
                      })
                  ]
                : [])
        ]);

        // now that all files are uploaded, kick off the workload
        await axios({
            url: initializedWorkloadResult.startWorkload,
            method: 'post'
        });
        this.logger.debug('started workload');

        // wait until the workload is done
        await this.waitUntilDone({
            sseUrl: initializedWorkloadResult.progress.sse,
            progressCallback: (sparkEvent: SparkEvent) => {
                progressCallback(null, sparkEvent);
            }
        });

        // fetch the result
        this.logger.debug('workload finished, fetching workload result');
        const workloadResult = await axios({
            url: initializedWorkloadResult.workloadResult,
            method: 'get'
        });
        this.logger.debug('got workload result', {
            status: workloadResult.status,
            statusText: workloadResult.statusText
        });

        return workloadResult.data;
    }

    waitUntilDone({
        sseUrl,
        progressCallback,
        retryCount = 0
    }: {
        sseUrl: string;
        progressCallback?: (sparkEvent: SparkEvent) => void;
        retryCount?: number;
    }): Promise<void> {
        this.logger.debug('subscribe to server-side-events', { retryCount });
        const sse = new EventSource(sseUrl);
        return new Promise((resolve, reject) => {
            sse.onerror = (event) => {
                sse.close();
                this.logger.error('server-side-event error', { event });
                if (retryCount < 3) {
                    setTimeout(() => {
                        resolve(
                            this.waitUntilDone({
                                sseUrl,
                                progressCallback,
                                retryCount: retryCount + 1
                            })
                        );
                    }, 1000);
                } else {
                    this.logger.error('got 3 server-side-event errors, aborting');
                    reject(new Error('SSE failed'));
                }
            };

            sse.addEventListener('message', (event) => {
                this.logger.debug('eventsource event:', { event });
                try {
                    const sparkEvent = JSON.parse(event.data) as SparkEvent;
                    if (!sparkEvent.latest) {
                        return;
                    }
                    progressCallback?.(sparkEvent);
                    const percentage = sparkEvent.latest.percentage;
                    if (typeof percentage === 'number' && percentage === 100) {
                        sse.close();
                        resolve();
                    }
                } catch (error) {
                    sse.close();
                    reject(new Error('Could not parse Spark event'));
                }
            });
        });
    }
}

type SparkEvent = {
    latest?: SparkEventProgressMessage;
    allProgress?: SparkEventProgressMessage[];
};

type SparkEventProgressMessage = {
    percentage?: number;
    categoryMessage?: string;
    progressMessage?: string;
    systemFailure?: boolean;
    errorMessage?: string;
};

type ProgressCallback = (localEvent: { percent: number; categoryMessage: string; progressMessage: string } | null, remoteSparkEvent?: SparkEvent) => void;

function createProgressCallback(progressCallback: CustomActionProgressFunction): ProgressCallback {
    const localProgressBefore: SparkEventProgressMessage[] = [];
    const localProgressAfter: SparkEventProgressMessage[] = [];
    let remoteProgress: SparkEventProgressMessage[] = [];
    let gotRemoteEvents = false;

    const adjustPercentage = (percentage?: number) => {
        return 10 + Math.floor((percentage ?? 0) * 0.8);
    };

    return (localEvent: { percent: number; categoryMessage: string; progressMessage: string } | null, remoteSparkEvent?: SparkEvent) => {
        let sparkEvent: SparkEvent | undefined;
        if (remoteSparkEvent) {
            gotRemoteEvents = true;
            remoteProgress =
                remoteSparkEvent.allProgress?.map((step) => {
                    return {
                        ...step,
                        percentage: adjustPercentage(step.percentage)
                    };
                }) ?? remoteProgress;
            if (remoteSparkEvent.latest) {
                sparkEvent = {
                    ...remoteSparkEvent,
                    latest: {
                        ...remoteSparkEvent.latest,
                        percentage: adjustPercentage(remoteSparkEvent.latest.percentage)
                    },
                    allProgress: localProgressBefore.concat(remoteProgress ?? [])
                };
            }
        } else if (localEvent) {
            const latest = createSparkEventProgressMessage(localEvent);
            if (!gotRemoteEvents) {
                localProgressBefore.push(latest);
                sparkEvent = {
                    latest,
                    allProgress: localProgressBefore
                };
            } else {
                localProgressAfter.push(latest);
                sparkEvent = {
                    latest,
                    allProgress: localProgressBefore.concat(remoteProgress, localProgressAfter)
                };
            }
        }
        if (sparkEvent?.latest) {
            progressCallback?.({
                percent: sparkEvent.latest?.percentage,
                message: JSON.stringify(sparkEvent)
            });
        }
    };
}

function createSparkEventProgressMessage(options: {
    percent: number;
    categoryMessage: string;
    progressMessage: string;
    systemFailure?: boolean;
    errorMessage?: string;
}): SparkEventProgressMessage {
    return {
        percentage: options.percent,
        categoryMessage: options.categoryMessage,
        progressMessage: options.progressMessage,
        systemFailure: options.systemFailure,
        errorMessage: options.errorMessage
    };
}

function hashCode(str: string) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
        const code = str.charCodeAt(i);
        hash = (hash << 5) - hash + code;
        hash = hash & hash; // Convert to 32bit integer
    }
    return hash;
}

type SparkKnowledge = {
    scopes: ScopeSelections;
    selected: SparkKnowledgeSelection[];
};

type ScopeSelections = {
    shared?: 'netlify-known' | 'public';
    orgId?: string;
    accountId?: string;
    siteId?: string;
};

type SparkKnowledgeSelection = {
    type: string;
    scopeType?: keyof ScopeSelections;
    id?: string;
};

function getKnowledgeForInputData(inputData?: Record<string, any>): SparkKnowledge | undefined {
    if (!inputData) {
        return undefined;
    }
    const selected: SparkKnowledgeSelection[] = [];
    if (inputData._spark_ai_voiceTone) {
        selected.push({
            type: 'voice-and-tone',
            id: inputData._spark_ai_voiceTone
        });
    }
    if (inputData._spark_ai_targetAudience) {
        selected.push({
            type: 'target-audience',
            id: inputData._spark_ai_targetAudience
        });
    }
    if (selected.length === 0) {
        return undefined;
    }
    return {
        scopes: {
            shared: 'netlify-known'
        },
        selected
    };
}

async function fetchGoogleDoc(options: CustomActionRunCommonOptions, progressCallback: ProgressCallback): Promise<string | undefined> {
    const googleDocUrl = options.inputData?._spark_ai_googleDocUrl ?? options.inputData?._spark_ai_content;
    const match = googleDocUrl?.match(/docs\.google\.com\/document\/d\/([^/]+)\//);
    if (!match) {
        return;
    }
    const googleDocId = match[1];
    if (!googleDocId) {
        return;
    }

    let googleConnection;
    if (options.currentUser && 'connections' in options.currentUser && Array.isArray(options.currentUser.connections)) {
        googleConnection = options.currentUser.connections.find((connection) => connection.type === 'google');
    }
    if (!googleConnection || !('accessToken' in googleConnection)) {
        throw new Error('Please connect your google account');
    }

    progressCallback({
        percent: 2,
        categoryMessage: 'Initializing',
        progressMessage: `Fetching from ${googleDocUrl}`
    });

    // const url = `https://docs.google.com/feeds/download/documents/export/Export?id=${documentId}&exportFormat=markdown`;
    const url = `https://www.googleapis.com/drive/v3/files/${googleDocId}/export?mimeType=text/markdown`;
    const googleDocResult = await axios({
        url: url,
        method: 'get',
        headers: {
            Authorization: `Bearer ${googleConnection.accessToken}`
        }
    });
    return googleDocResult.data;
}

export const Actions = {
    GenerateContentFromPreset
};
